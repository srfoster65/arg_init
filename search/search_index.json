{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>When running code there is often a requirement to initialise arguments either directly from a passed in value, indirectly via an environment variable or config file or a via default value. Argparse provides this functionality (or can be easily augmented to, with the exception of loading from a config file) already but has one major drawback; It does not work when the code is invoked as a library.</p> <p>arg_init provides functionality to resolve argument values for a given function/method from either a config file, an environment variable, an argument value or a default value. Introspection is used to determine the arguments of the calling function, and a dictionary is created of resolved values for each argument. Resolved values are determined using a predefined priority system that can be customised by the user.</p> <p>When resolving from an environment variable, the environment variable name is assumed to be the same as the argument name, in uppercase e.g. An argument, arg1 would resolve from an environment variable, \"ARG1\". This behaviour can be modified by providing an alternate name via argument defaults or by setting an env_prefix.</p> <p>If the calling function is a class method, arguments may also be made available as class attributes. See reference for more details.</p> <p>Because argument initialisation is implemented in the application, it will work if called via a CLI script or as a library by another python program.</p> <p>arg_init provides two classes; ClassArgInit and FunctionArgInit for initialising arguments of bound class functions and unbound functions respectively. These classes iterate over all arguments of the calling function, exposing a dictionary containing key/value pairs of argument name, with values assigned according to the priority system selected.</p>"},{"location":"#notes","title":"Notes","text":"<p>arg_init uses introspection (via the inspect module) to determine function arguments and values. Its use is minimal and is only executed once at startup so performance should not be an issue.</p> <p>It is not practical to dynamically determine if the function to be processed is a bound function (a class method, with a class reference (self) as the first parameter) or an unbound function (a simple function), so selection is determined by the use of the called class: ClassArgInit of FunctionArgInit.</p> <p>Fucntionality is identical for both implementations, with the following exception:</p> <p>ClassArgInit:</p> <ul> <li>Class attributes are set (may be optionally disabled) that represent the resolved argument values</li> </ul>"},{"location":"#priority","title":"Priority","text":"<p>The argument value is set when a non None value is found, or all options are exhausted. At this point the argument is set to None.</p> <p>What priority should be used to set an argument?</p>"},{"location":"#argument-priority-order","title":"Argument Priority Order","text":"<p>If passed in arguments have priorty:</p> <p>And if the function has a non None default argument e.g. f(a=1), then the argument value will always be used to set the value, never allowing a config or env value to take effect.</p> <p>There are two obvious solutions to this:</p> <ol> <li>Lower the priority of arguments.</li> <li>Provide an alternate means to specify a default value. If a default value is required in the function signature, to allow ommission of an argument when calling, ensure it is set to None.</li> </ol>"},{"location":"#default-values","title":"Default Values","text":"<p>The problem: How to avoid violating the DRY principle when an application can be invoked via a CLI or as a library.</p> <p>If an application is to be called as a library then the defaults MUST be implemented in the application, not the CLI script. But ArgumentParser will pass in None values if no value is specified for an argument. This None value will be used in preference to function default! So defaults must be also be specified in ArgumentParser and the applicication. This is not a good design pattern.</p> <p>Providing an alternate means to specify a default value resolves this.</p>"},{"location":"#priority-order","title":"Priority Order","text":"<p>arg-init supports customisable priority models. It is left to the user to select an appropriate priority sequence (or use the default option) for each specfic use case.</p>"},{"location":"#default-priority-order","title":"Default Priority Order","text":"<p>The default priority implemented is:</p> <p>CONFIG_PRIORITY</p> <ol> <li>Config</li> <li>Env</li> <li>Arg</li> <li>Default</li> </ol>"},{"location":"#predefined-priority-orders","title":"Predefined Priority Orders","text":"<p>Two further predifined priority models are provided</p> <ul> <li>ENV_PRIORITY</li> <li>ARG_PRIOIRTY</li> </ul> <p>The user may also define a custom priority order if the predefined options are not suitable.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#simple-useage","title":"Simple Useage","text":"<p>The following examples show how to use arg_init to initialise a class or function</p> <pre><code>from arg_init import ClassArgInit\n\nclass MyApp:\n    def __init__(self, arg1):\n        ClassArgInit()\n        ...\n</code></pre> <pre><code>from arg_init import FunctionArgInit\n\ndef func(arg1):\n    FunctionArgInit()\n    ...\n</code></pre> <p>In the examples above, arg1 will be initialised with the value from the config file, the environment variable \"ARG1\", else it will take the passed in value. Finally it will have a default value of None assigned.</p> <p>As these examples use the default priority sytem, they will not work if used with ArgumentParser without ArgumentParser replicating the default values.</p>"},{"location":"#other-use-cases","title":"Other use cases","text":"<p>The example below shows how to change the environment variable name used to initialise the argument using ArgDefaults.</p> <pre><code>from arg_init import FunctionArgInit, ArgDefaults\n\ndef func(arg1):\n    arg1_defaults = ArgDefaults(env_name=\"TEST\")\n    args = FunctionArgInit(defaults={\"arg1\": arg1_defaults}).args\n    ...\n</code></pre> <p>The example below shows how to use argument priority when resolving the values of arguments.</p> <pre><code>from arg_init import FunctionArgInit, ARG_PRIOIRITY, ArgDefaults\n\ndef func(arg1):\n    arg1_defaults = ArgDefaults(\"arg1\", default_value=1)\n    args = FunctionArgInit(priority=ARG_PRIORITY, defaults=[arg1_defaults]).args\n    ...\n</code></pre>"},{"location":"#recommendation","title":"Recommendation","text":"<p>To avoid namespace clashes with environment variables, it is recommneded to always supply an env_prefix argument when initialising ClassArgInit/FunctionArgInit. All environment variables are expected to have this prefix e.g. with an env_prefix of \"myapp\", arg1 would map to the environment variable \"MYAPP_ARG1\".</p> <pre><code>from arg_init import ClassArgInit\n\nclass MyApp:\n    def __init__(self, arg1):\n        args = ClassArgInit(env_prefix=\"myapp\").args\n        ...\n</code></pre> <p>Note: In this example, arg1 would resolve against the environment variable \"MYAPP_ARG1\".</p> <p>Please see the documentation for further details on usage.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>The format is based on Keep a Changelog and uses Conventional Commits to document updates.</p> <p>This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#releases","title":"Releases","text":""},{"location":"changelog/#001-2023-10-11","title":"[0.0.1] - 2023-10-11","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Pre Release</li> </ul>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2023 Stephen Foster\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#classarginit","title":"ClassArgInit","text":"<pre><code>ClassArgInit(priorities=DEFAULT_PRIORITY, env_prefix=None, use_kwargs=False, defaults=None, config=\"config\", set_attrs=True, protect_atts=True)\n</code></pre> <p>Resolve argument values using the bound function that calls ClassArgInit as the reference. Process each argument (skipping the first argument as this is a class reference) from the calling function, resolving and storing the value in a dictionary, where the argument name is the key.</p>"},{"location":"reference/#arguments","title":"Arguments","text":"<ul> <li> <p>priorities: By default arguments will be set based on the priority sequence: config, env, arg, default. Several alternate priority sequences are predefined, or a custom sequence can be defined.</p> </li> <li> <p>env_prefix: env_prefix is used to avoid namespace clashes with environment variables. If set, all environment variables must include this prefix followed by an \"_\" character and the name of the argument.</p> </li> <li> <p>use_kwargs: When initialising arguments, only named arguments will be initialised by default. If use_kwargs=True, then any keyword arguments will also be initialised</p> </li> <li> <p>defaults: A list of ArgDefault objects.</p> </li> <li> <p>config: The name of the config file to load defaults from. If this is a Path object it can be a relative or absolute path to a config file. If a string, it can be the name of the file (excluding the extension). Default is to search for a file named \"config\" in the current working directory.</p> </li> <li> <p>set_attrs: Set the arguments as class attributes. Default is true.</p> </li> <li> <p>protect_attrs: Add a leading \"_\" character to all assigned attribute names. Default is True.</p> </li> </ul>"},{"location":"reference/#attributes","title":"Attributes","text":""},{"location":"reference/#args","title":"args","text":"<p>An object representing the resolved arguments. Arguments are exposed as attributes or key/value pairs.</p> <p>Note: The returned object is a python-box Box class.</p>"},{"location":"reference/#functionarginit","title":"FunctionArgInit","text":"<pre><code>FunctionArgInit(env_prefix=None, priority=DEFAULT_PRIORITY, use_kwargs=False, defaults=None, config=\"config\")\n</code></pre> <p>Resolve argument values using the function that calls FunctionArgInit as the reference. Process each argument from the calling function, resolving and storing the value in a dictionary, where the argument name is the key.</p>"},{"location":"reference/#arguments_1","title":"Arguments","text":"<ul> <li>priorities: By default arguments will be set based on the priority sequence:  config, env, arg, default. Several alternate priority sequences are predefined, or a custom sequence can be defined.</li> <li></li> <li> <p>env_prefix: env_prefix is used to avoid namespace clashes with environment variables. If set, all environment variables must include this prefix followed by an \"_\" character and the name of the argument.</p> </li> <li> <p>use_kwargs: When initialising arguments, only named arguments will be initialised by default. If use_kwargs=True, then any keyword arguments will also be initialised</p> </li> <li> <p>defaults: A list of ArgDefault objects.</p> </li> <li> <p>config: The name of the config file to load defaults from. If this is a Path object it can be a relative or absolute path to a config file. If a string, it can be the name of the file (excluding the extension). Default is to search for a file named \"config\" in the current working directory.</p> </li> </ul>"},{"location":"reference/#attributes_1","title":"Attributes","text":""},{"location":"reference/#args_1","title":"args","text":"<p>An object representing the resolved arguments. Arguments are exposed as attributes or key/value pairs.</p> <p>Note: The returned object is a python-box Box class.</p>"},{"location":"reference/#argdefaults","title":"ArgDefaults","text":"<pre><code>ArgDefaults(name, default_value=None, env_name=\"\")\n</code></pre> <p>A class that can be used to modify settings for an individual argument.</p>"},{"location":"reference/#arguments_2","title":"Arguments","text":"<ul> <li> <p>env_name: The name of the associated environment variable. If not set, env defaults to the uppercase equivalent of the argument name.</p> </li> <li> <p>default_value: The default value to be applied if both arg and env values are not used.</p> </li> </ul>"},{"location":"reference/#priorities","title":"Priorities","text":""},{"location":"reference/#priority-sequences","title":"Priority Sequences","text":"<p>A prioity sequence defines the resolution priority when resolving argument values. It is a list of Priority eunums.</p> <p>The following priority sequences are defined:</p> <ul> <li>CONFIG_PRIORITY = CONFIG, ENV, ARG, DEFAULT</li> <li>ENV_PRIORITY = ENV, CONFIG, ARG, DEFAULT</li> <li>ARG_PRIORITY = ARG, CONFIG, ENV, DEFAULT</li> </ul> <p>DEFAULT_PRIORITY = CONFIG_PRIORITY</p> <p>The following Priority values are defined:</p> <ul> <li>Priority.CONFIG</li> <li>Priority.ENV</li> <li>Priority.ARG</li> <li>Priority.DEFAULT</li> </ul> <p>These values can be used to define a custom priority sequence. If a Priority is omitted, then it will not be used in the resolution process.</p> <p>e.g.</p> <pre><code>priorities = list(Priority.ENV, Priority.ARG, Priority.DEFAULT)\n</code></pre> <p>Will define a priority sequence that does not use a config file during the resolution process.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installation","title":"Installation","text":"<p>With Pip:</p> <pre><code>pip install arg_init\n</code></pre>"},{"location":"usage/#basic-usage-for-class-functions","title":"Basic Usage for Class functions","text":"<p>For Class methods: ClassArgInit() should be called from a class __init__() method that arguments should be processed for.</p> <pre><code>from arg_init import ClassArgInit\n\nclass MyClass:\n    def __init__(self, arg1=99):\n        ClassArgInit().args\n        print(self._arg1)\n</code></pre> <p>Resolved arguments are exposed as protected class attributes e.g. \"self._arg1\".</p>"},{"location":"usage/#basic-usage-for-simple-functions","title":"Basic Usage for simple functions","text":"<p>FunctionArgInit() should be called from a function that arguments should be processed for.</p> <pre><code>from arg_init import FunctionArgInit\n\ndef my_func(arg1=None):\n    args = FunctionArgInit().args\n    print(args.arg1)\n</code></pre> <p>Resolved arguments are exposed by accessing the args attribute of FunctionArgInit. Resolved values can be accessed as attributes e.g. args.arg1 or as a dictionary item e.g. args[\"arg1\"].</p>"},{"location":"usage/#other-use-cases","title":"Other Use Cases","text":""},{"location":"usage/#using-config-files-to-resolve-argument-values","title":"Using config files to resolve argument values","text":"<p>By default arg-init will search for a config file named \"config\", with the extension: toml, yaml, json (in that order) in the current working directory. This behaviour can be overridden by specifying an absolute or relative path to a different config file.</p>"},{"location":"usage/#toml-files","title":"TOML files","text":"<p>The section heading should be the name of the class, if using ClassArgInit or the name of the function, if using FunctionArgInit.</p> <pre><code>[MyApp]\narg1 = 42\n</code></pre>"},{"location":"usage/#yaml-files","title":"YAML Files","text":"<p>The top level dictionary key should be the name of the class, if using ClassArgInit or the name of the function, if using FunctionArgInit.</p> <pre><code>MyApp:\n  arg1: 42\n</code></pre>"},{"location":"usage/#json-files","title":"JSON Files","text":"<p>The top level dictionary key should be the name of the class, if using ClassArgInit or the name of the function, if using FunctionArgInit.</p> <pre><code>{\n  \"MyApp\":\n  {\n    \"arg1\": 42\n  }\n}\n</code></pre>"},{"location":"usage/#setting-a-common-prefix-for-all-environment-variables","title":"Setting a Common Prefix for all Environment Variables","text":"<p>To avoid namespace clashes with environment variables, it is recommneded to always supply an env_prefix argument when initialising ClassArgInit/FunctionArgInit. All environment variables are expected to have this prefix e.g. with an env_prefix of \"myapp\", arg1 would map to the environment variable \"MYAPP_ARG1\".</p> <pre><code>env_prefix=&lt;string&gt;\n</code></pre> <p>env_prefix is converted to uppercase before use.</p> <pre><code>from arg_init import ClassArgInit\n\nclass MyApp:\n    def __init__(self, arg1=None):\n        args = ClassArgInit(env_prefix=\"myapp\").args\n        ...\n</code></pre>"},{"location":"usage/#priority-modes","title":"Priority Modes","text":"<p>Support for selecting the priority resolution mode is provided via the argument priority.</p> <pre><code>priority=ENV_PRIORITY | ARG_PRIORITY\n</code></pre> <p>By default, enviroment variables have priority over argument values. This can be changed at initialisation to give arguments prioirty.</p> <pre><code>from arg_init import FunctionArgInit, ARG_PRIORITY\n\ndef my_func(arg1):\n    arg_init = FunctionArgInit()\n    args = arg_init.resolve(priority=ARG_PRIORITY)\n    ...\n</code></pre> <p>Note: When using ARG_PRIORITY a default value should also be provided by ArgDefaults is a default value other than None is required.</p>"},{"location":"usage/#overriding-default-argument-behaviour","title":"Overriding Default Argument Behaviour","text":"<p>It is possible to override default behaviour per argument using the ArgDefault object. A list of ArgDefaults objects can be passed into the call to ClassArgInit/FunctionArgInit.</p> <p>ArgDefaults takes a \"name\" argumment and zero or more of the following optional arguments:</p> <ul> <li>default_value</li> <li>env_name</li> </ul>"},{"location":"usage/#default_value","title":"default_value","text":"<p>When using ARG_Priority, the only way to set a default value is to the use ArgDefaults(default_value=value)</p> <p>This can also be used when using ENV_Priority but the recommended solution is to use default python behaviour using function defaults e.g. fn(a=1).</p>"},{"location":"usage/#env_name","title":"env_name","text":"<p>Setting this value allows a custom env name to be set as the lookup for an argument. This overrides the default setting and ignores any env prefix settings.</p> <p>Note: env_name is converted to uppercase before use.</p>"},{"location":"usage/#example-using-argdefaults","title":"Example using ArgDefaults","text":"<p>In the example below, arg1 is modified to have a default value of 1 and to resolve from the environmnet variable \"ALT_NAME\"</p> <pre><code>from arg_init import FunctionArgInit, ArgDefaults\n\ndef func(arg1=None):\n    arg1_defaults = ArgDefaults(name=\"arg1\", default_value=1, env_name=\"ALT_NAME\")\n    args = FunctionArgInit(defaults=[arg1_defaults]).args\n    ...\n</code></pre>"},{"location":"usage/#use-with-a-class","title":"Use with a Class","text":"<p>There are two additional class specific configuration options available:</p> <ul> <li>set_attrs: default=True</li> <li>protect_attr: default=True</li> </ul> <p>By default, ClassArgInit will set attributes directly on the calling class, using the argument name, with an \"_\" prefix for each argument in the calling functions' signature.</p> <p>Setting set_attrs to False will prevent ClassArgInit from setting these class attributes.</p> <p>Setting protect_attrs to False will cause the attributes to be set using the argument name, without a leading \"_\" character.</p> <pre><code>from arg_init import ArgInit\n\nclass MyApp:\n    def __init__(self, arg1=None):\n        ClassArgInit(set_attrs=True, protect_attrs=False)\n        ...\n</code></pre> <p>By default, ClassArgInit will set all arguments as protected class attributes of the MyApp instance. In the above example, arg1 will be available as an attribute \"arg1\" of the instance of MyApp.</p>"},{"location":"usage/#support-for-kwargs","title":"Support for kwargs","text":"<p>Support for kwargs in function signatures is provided via the argument use_kwargs. When this argument is set, any keword arguments would be initialised using the same resolution process as named arguments.</p> <pre><code>from arg_init import FunctionArgInit\n\ndef my_func(self, **kwargs):\n    args = FunctionArgInit(use_kwargs=True)\n    ...\n</code></pre>"},{"location":"usage/#using-a-custom-prioirity-sequence","title":"Using a Custom Prioirity Sequence","text":"<p>A custom priority sequence can be defined. This can be used, for example, to disable a specific resolution feature.</p> <pre><code>from arg_init import FunctionArgInit, Priority\n\ndef my_func(self, **kwargs):\n    priorities = list(Priority.ENV, Priority.ARG, Priority.DEFAULT)\n    args = FunctionArgInit(priorities=priorities)\n    ...\n</code></pre> <p>The example above disables the use of a config file during the resolution process.</p>"}]}